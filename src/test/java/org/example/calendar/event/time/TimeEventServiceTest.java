package org.example.calendar.event.time;

import org.example.calendar.AbstractRepositoryTest;
import org.example.calendar.email.EmailService;
import org.example.calendar.entity.User;
import org.example.calendar.event.recurrence.RecurrenceDuration;
import org.example.calendar.event.recurrence.RecurrenceFrequency;
import org.example.calendar.event.slot.time.TimeEventSlotPublicProjectionAssert;
import org.example.calendar.event.slot.time.TimeEventSlotRepository;
import org.example.calendar.event.slot.time.projection.TimeEventSlotPublicProjection;
import org.example.calendar.event.time.dto.TimeEventInvitationRequest;
import org.example.calendar.event.time.dto.TimeEventRequest;
import org.example.calendar.event.slot.time.TimeEventSlotService;
import org.example.calendar.exception.ResourceNotFoundException;
import org.example.calendar.user.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.jdbc.Sql;

import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

@ExtendWith(MockitoExtension.class)
@Import({TimeEventRepository.class, TimeEventSlotRepository.class, UserRepository.class})
class TimeEventServiceTest extends AbstractRepositoryTest {
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private TimeEventRepository timeEventRepository;
    @Autowired
    private TimeEventSlotRepository eventSlotRepository;
    private TimeEventSlotService timeEventSlotService;
    @Mock
    private EmailService emailService;
    private TimeEventService underTest;

    @BeforeEach
    void setup() {
        this.timeEventSlotService = new TimeEventSlotService(eventSlotRepository, userRepository);
        this.underTest = new TimeEventService(timeEventRepository, userRepository, timeEventSlotService, emailService);
    }

    @Test
    @Sql("/scripts/INIT_USERS.sql")
    void shouldCreateTimeEvent() {
        /*
            It is very important to use .truncatedTo(ChronoUnit.MICROS) because according to PSQL docs for date times
            it stores up to 6 decimal digits for the seconds precision.

            This is a date time generated by Java: 2024-10-14T21:59:31.156105600 This how it is stored in psql: 2024-10-14T21:59:31.1561056
            In our custom assert hasStart/EndTime would fail due to precision issues. We can also work with ChronoUnit.MINUTES
            2024-10-14T21:59
         */
        LocalDateTime startTime = LocalDateTime.now(ZoneId.of("Asia/Tokyo")).plusMinutes(30).truncatedTo(ChronoUnit.MINUTES);
        LocalDateTime endTime = LocalDateTime.now(ZoneId.of("Asia/Tokyo")).plusHours(2).truncatedTo(ChronoUnit.MINUTES);

        User user = User.builder()
                .id(2L)
                .username("clement.gulgowski")
                .email("ericka.ankunding@hotmail.com")
                .build();
        TimeEventRequest eventRequest = TimeEventRequest.builder()
                .title("Event title")
                .location("Location")
                .startTime(startTime)
                .startTimeZoneId(ZoneId.of("Asia/Tokyo"))
                .endTime(endTime)
                .endTimeZoneId(ZoneId.of("Asia/Tokyo"))
                .recurrenceFrequency(RecurrenceFrequency.NEVER)
                .guestEmails(Collections.emptySet())
                .build();
        // We don't have to call any(TimeEventInvitationRequest.class) for the email service. We know exactly how that request will look like
        // and can verify that our email service is called with the expected email request
        TimeEventInvitationRequest emailRequest = TimeEventInvitationRequest.builder()
                .eventName(eventRequest.getTitle())
                .location(eventRequest.getLocation())
                .organizer(user.getUsername())
                .guestEmails(eventRequest.getGuestEmails())
                .recurrenceFrequency(eventRequest.getRecurrenceFrequency())
                .recurrenceStep(eventRequest.getRecurrenceStep())
                .weeklyRecurrenceDays(eventRequest.getWeeklyRecurrenceDays())
                .monthlyRecurrenceType(eventRequest.getMonthlyRecurrenceType())
                .recurrenceDuration(eventRequest.getRecurrenceDuration())
                .recurrenceEndDate(eventRequest.getRecurrenceEndDate())
                .numbersOfOccurrences(eventRequest.getNumberOfOccurrences())
                .startTime(eventRequest.getStartTime())
                .endTime(eventRequest.getEndTime())
                .startTimeZoneId(eventRequest.getStartTimeZoneId())
                .endTimeZoneId(eventRequest.getEndTimeZoneId())
                .build();
        doNothing().when(this.emailService).sendInvitationEmail(emailRequest);

        UUID eventId = this.underTest.createEvent(2L, eventRequest);

        // We can not call findEventSlotsByEventId, because we don't have access to the auto generate event id
        List<TimeEventSlotPublicProjection> projections = this.timeEventSlotService.findEventSlotsByUserInDateRange(user, LocalDateTime.now(eventRequest.getStartTimeZoneId()), eventRequest.getStartTimeZoneId(), LocalDateTime.now(eventRequest.getStartTimeZoneId()).plusHours(5), eventRequest.getEndTimeZoneId());

        assertThat(eventId).isNotNull();
        TimeEventSlotPublicProjectionAssert.assertThat(projections.get(0))
                .hasStartTime(startTime)
                .hasEndTime(endTime)
                .hasStartTimeZoneId(ZoneId.of("Asia/Tokyo"))
                .hasEndTimeZoneId(ZoneId.of("Asia/Tokyo"))
                .hasTitle("Event title")
                .hasLocation("Location")
                .hasDescription(null)
                .hasGuests(Collections.emptySet());

        verify(this.emailService, times(1)).sendInvitationEmail(emailRequest);
    }

    /*
        In this method, the event request we provide has different frequency properties and start/end time from the
        current state of the resource(event). In this case, we delete all the event slots(3) and compute the new ones
        based on the event request.
     */
    @Test
    @Sql({"/scripts/INIT_USERS.sql", "/scripts/INIT_EVENTS.sql"})
    void shouldUpdateEvent_1() {
        LocalDateTime startTime = LocalDateTime.now(ZoneId.of("Asia/Tokyo")).plusMinutes(20).truncatedTo(ChronoUnit.MICROS);
        LocalDateTime endTime = LocalDateTime.now(ZoneId.of("Asia/Tokyo")).plusHours(5).truncatedTo(ChronoUnit.MICROS);

        UUID eventId = UUID.fromString("0c9d6398-a6de-47f0-8328-04a2f3c0511c");
        TimeEventRequest eventRequest = TimeEventRequest.builder()
                .location("Location")
                .startTime(startTime)
                .startTimeZoneId(ZoneId.of("Asia/Tokyo"))
                .endTime(endTime)
                .endTimeZoneId(ZoneId.of("Asia/Tokyo"))
                .recurrenceFrequency(RecurrenceFrequency.NEVER)
                .guestEmails(Collections.emptySet())
                .build();

        this.underTest.updateEvent(1L, eventId, eventRequest);

        List<TimeEventSlotPublicProjection> projections = this.timeEventSlotService.findEventSlotsByEventAndUserId(eventId, 1L);

        assertThat(projections).hasSize(1);
        TimeEventSlotPublicProjectionAssert.assertThat(projections.get(0))
                .hasStartTime(startTime)
                .hasStartTimeZoneId(ZoneId.of("Asia/Tokyo"))
                .hasEndTime(endTime)
                .hasEndTimeZoneId(ZoneId.of("Asia/Tokyo"))
                .hasTitle(null)
                .hasLocation("Location")
                .hasDescription(null)
                .hasGuests(Collections.emptySet())
                .hasEventId(eventId);
    }

    /*
        In this method, the event request we provide has the same frequency properties and start/end date time with the
        current state of the resource(event). In this case, we update title/location/description/guestEmails to all of
        the event's slots(3).
     */
    @Test
    @Sql({"/scripts/INIT_USERS.sql", "/scripts/INIT_EVENTS.sql"})
    void shouldUpdateEvent_2() {
        UUID eventId = UUID.fromString("0c9d6398-a6de-47f0-8328-04a2f3c0511c");
        TimeEventRequest eventRequest = TimeEventRequest.builder()
                .location("Location")
                .startTime(LocalDateTime.parse("2024-10-11T09:00:00"))
                .startTimeZoneId(ZoneId.of("Europe/London"))
                .endTime(LocalDateTime.parse("2024-10-15T14:00:00"))
                .endTimeZoneId(ZoneId.of("Europe/London"))
                .recurrenceFrequency(RecurrenceFrequency.WEEKLY)
                .recurrenceStep(2)
                .weeklyRecurrenceDays(EnumSet.of(DayOfWeek.FRIDAY))
                .recurrenceDuration(RecurrenceDuration.N_OCCURRENCES)
                .numberOfOccurrences(3)
                .guestEmails(Collections.emptySet())
                .build();

        this.underTest.updateEvent(1L, eventId, eventRequest);

        List<TimeEventSlotPublicProjection> projections = this.timeEventSlotService.findEventSlotsByEventAndUserId(eventId, 1L);

        assertThat(projections).hasSize(3);
        projections.forEach(projection -> TimeEventSlotPublicProjectionAssert.assertThat(projections.get(0))
                .hasTitle(null)
                .hasLocation("Location")
                .hasDescription(null)
                .hasGuests(Collections.emptySet())
                .hasEventId(eventId)
        );
    }

    /*
        There are 2 cases where the findByEventIdAndUserId() could throw ResourceNotFoundException.
            1. Event exists but the authenticated user is not the organizer
            2. Event does not exist
         In either case it is 404
     */
    @Test
    void shouldThrowResourceNotFoundExceptionForUpdateEvent() {
        TimeEventRequest eventRequest = TimeEventRequest.builder()
                .title("Event title")
                .build();
        UUID eventId = UUID.randomUUID();

        assertThatExceptionOfType(ResourceNotFoundException.class).isThrownBy(() -> this.underTest.updateEvent(2L, eventId, eventRequest)).withMessage("Time event not found with id: " + eventId);
    }

    // We can also assert that findByEventSlotsByEventId returns an empty list. Event slots are delete for the event with ON DELETE CASCADE
    @Test
    @Sql({"/scripts/INIT_USERS.sql", "/scripts/INIT_EVENTS.sql"})
    void shouldDeleteEvent() {
        UUID eventId = UUID.fromString("00026b7d-85ad-490a-8875-a85b3e5f37de");
        this.underTest.deleteEventById(eventId, 2L);

        // 0 rows affected
        assertThatExceptionOfType(ResourceNotFoundException.class).isThrownBy(() -> this.underTest.deleteEventById(eventId, 1L)).withMessage("Time event not found with id: " + eventId);
    }

    /*
        There are 2 cases where the deleteEventById() could throw ResourceNotFoundException.
            1. Event exists but the authenticated user is not the organizer
            2. Event does not exist
         In either case it is 404
     */
    @Test
    void shouldThrowResourceNotFoundExceptionForDeleteById() {
        UUID eventId = UUID.randomUUID();
        assertThatExceptionOfType(ResourceNotFoundException.class).isThrownBy(() -> this.underTest.deleteEventById(eventId, 2L)).withMessage("Time event not found with id: " + eventId);
    }
}
